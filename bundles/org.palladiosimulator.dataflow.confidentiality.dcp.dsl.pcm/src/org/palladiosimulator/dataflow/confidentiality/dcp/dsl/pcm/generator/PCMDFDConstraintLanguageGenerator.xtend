/*
 * generated by Xtext 2.24.0
 */
package org.palladiosimulator.dataflow.confidentiality.dcp.dsl.pcm.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.sebinside.dcp.dsl.dSL.TargetModelTypeDef
import org.palladiosimulator.dataflow.confidentiality.pcm.workflow.TransitiveTransformationTrace
import de.sebinside.dcp.dsl.generator.DSLGenerator
import org.palladiosimulator.dataflow.confidentiality.dcp.dsl.pcm.converter.PCMDFDConverter
import de.sebinside.dcp.dsl.dSL.Constraint
import org.palladiosimulator.supporting.prolog.model.prolog.PrologFactory
import de.sebinside.dcp.dsl.dSL.CharacteristicClass
import org.palladiosimulator.dataflow.confidentiality.dcp.dsl.pcm.pCMDFDConstraintLanguage.Model
import de.sebinside.dcp.dsl.dSL.Rule
import org.palladiosimulator.dataflow.confidentiality.dcp.dsl.pcm.queryrule.PCMDFDInputPinQueryRule
import de.sebinside.dcp.dsl.generator.crossplatform.Converter

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PCMDFDConstraintLanguageGenerator extends DSLGenerator {
	
	TransitiveTransformationTrace transitiveTransformationTrace = null
	PCMDFDConverter pcmDFDConverter = null

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// intentionally empty, so the editor does not try to generate a output
	}
	
	def generateFromModel(Model model) { // potentially not necessary, but could be usefull to differentiate the two DSLs
		val program = PrologFactory.eINSTANCE.createProgram
		model.targetModelType.compile
		
		for (charClass : model.elements.filter(CharacteristicClass)) {
			program.clauses.addAll(charClass.compile)
		}
		
		for (constraint : model.elements.filter(Constraint)) {
			program.clauses.addAll(constraint.compile)
		}
		
		program
	}

	override compile(TargetModelTypeDef typeDefs) {
		// There is only one or none target model type definition
		this.targetModelType = typeDefs.type
		
		switch this.targetModelType {
			case "PCMDFD": { 
				if(transitiveTransformationTrace === null) {
						throw new Exception("No valid trace for DFD!")
				}
				this.pcmDFDConverter = new PCMDFDConverter(transitiveTransformationTrace)
				this.converter = this.pcmDFDConverter} 
			case "DFD": super.compile(typeDefs)
			default: throw new Exception("No valid type definition given!")
		}
	}
	
	override generateRule(Rule mainRule, String constraintName, Converter converter) {
		var inputRule = new PCMDFDInputPinQueryRule(mainRule, constraintName, pcmDFDConverter)
		inputRule.generate()
	}
	
	def setTransitiveTransformationTrace(TransitiveTransformationTrace trace) {
		this.transitiveTransformationTrace = trace
	}
	
	override getConverter(){
		this.pcmDFDConverter
	}
}
