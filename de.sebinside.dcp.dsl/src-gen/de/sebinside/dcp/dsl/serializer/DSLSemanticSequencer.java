/*
 * generated by Xtext 2.21.0
 */
package de.sebinside.dcp.dsl.serializer;

import com.google.inject.Inject;
import de.sebinside.dcp.dsl.dSL.AbstractElement;
import de.sebinside.dcp.dsl.dSL.AttributeClassSelector;
import de.sebinside.dcp.dsl.dSL.AttributeSelector;
import de.sebinside.dcp.dsl.dSL.BooleanOperation;
import de.sebinside.dcp.dsl.dSL.CharacteristicClass;
import de.sebinside.dcp.dsl.dSL.CharacteristicReference;
import de.sebinside.dcp.dsl.dSL.CharacteristicSet;
import de.sebinside.dcp.dsl.dSL.CharacteristicSetReference;
import de.sebinside.dcp.dsl.dSL.CharacteristicType;
import de.sebinside.dcp.dsl.dSL.CharacteristicTypeSelector;
import de.sebinside.dcp.dsl.dSL.CharacteristicVariable;
import de.sebinside.dcp.dsl.dSL.Condition;
import de.sebinside.dcp.dsl.dSL.Constraint;
import de.sebinside.dcp.dsl.dSL.CreateSetOperation;
import de.sebinside.dcp.dsl.dSL.DSLPackage;
import de.sebinside.dcp.dsl.dSL.ElementOfOperation;
import de.sebinside.dcp.dsl.dSL.EmptySetOperation;
import de.sebinside.dcp.dsl.dSL.Include;
import de.sebinside.dcp.dsl.dSL.IntersectionOperation;
import de.sebinside.dcp.dsl.dSL.LogicalAndOperation;
import de.sebinside.dcp.dsl.dSL.LogicalOrOperation;
import de.sebinside.dcp.dsl.dSL.Model;
import de.sebinside.dcp.dsl.dSL.NodeIdentitiySelector;
import de.sebinside.dcp.dsl.dSL.PropertyClassSelector;
import de.sebinside.dcp.dsl.dSL.PropertySelector;
import de.sebinside.dcp.dsl.dSL.Rule;
import de.sebinside.dcp.dsl.dSL.Statement;
import de.sebinside.dcp.dsl.dSL.StatementModality;
import de.sebinside.dcp.dsl.dSL.StatementType;
import de.sebinside.dcp.dsl.dSL.SubtractOperation;
import de.sebinside.dcp.dsl.dSL.TargetModelTypeDef;
import de.sebinside.dcp.dsl.dSL.UnionOperation;
import de.sebinside.dcp.dsl.dSL.VariableEqualityOperation;
import de.sebinside.dcp.dsl.dSL.VariableInequalityOperation;
import de.sebinside.dcp.dsl.services.DSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DSLPackage.ABSTRACT_ELEMENT:
				sequence_AbstractElement(context, (AbstractElement) semanticObject); 
				return; 
			case DSLPackage.ATTRIBUTE_CLASS_SELECTOR:
				sequence_AttributeClassSelector(context, (AttributeClassSelector) semanticObject); 
				return; 
			case DSLPackage.ATTRIBUTE_SELECTOR:
				sequence_AttributeSelector(context, (AttributeSelector) semanticObject); 
				return; 
			case DSLPackage.BOOLEAN_OPERATION:
				sequence_LogicalNegationOperation(context, (BooleanOperation) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_CLASS:
				sequence_CharacteristicClass(context, (CharacteristicClass) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_REFERENCE:
				sequence_CharacteristicReference(context, (CharacteristicReference) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_SET:
				sequence_CharacteristicSet(context, (CharacteristicSet) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_SET_REFERENCE:
				sequence_CharacteristicSetReference(context, (CharacteristicSetReference) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_TYPE:
				sequence_CharacteristicType(context, (CharacteristicType) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_TYPE_SELECTOR:
				sequence_CharacteristicTypeSelector(context, (CharacteristicTypeSelector) semanticObject); 
				return; 
			case DSLPackage.CHARACTERISTIC_VARIABLE:
				sequence_CharacteristicVariable(context, (CharacteristicVariable) semanticObject); 
				return; 
			case DSLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case DSLPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case DSLPackage.CREATE_SET_OPERATION:
				sequence_CreateSetOperation(context, (CreateSetOperation) semanticObject); 
				return; 
			case DSLPackage.ELEMENT_OF_OPERATION:
				sequence_ElementOfOperation(context, (ElementOfOperation) semanticObject); 
				return; 
			case DSLPackage.EMPTY_SET_OPERATION:
				sequence_EmptySetOperation(context, (EmptySetOperation) semanticObject); 
				return; 
			case DSLPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case DSLPackage.INTERSECTION_OPERATION:
				sequence_IntersectionOperation(context, (IntersectionOperation) semanticObject); 
				return; 
			case DSLPackage.LOGICAL_AND_OPERATION:
				sequence_LogicalAndOperation(context, (LogicalAndOperation) semanticObject); 
				return; 
			case DSLPackage.LOGICAL_OR_OPERATION:
				sequence_LogicalOrOperation(context, (LogicalOrOperation) semanticObject); 
				return; 
			case DSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DSLPackage.NODE_IDENTITIY_SELECTOR:
				sequence_NodeIdentitiySelector(context, (NodeIdentitiySelector) semanticObject); 
				return; 
			case DSLPackage.PROPERTY_CLASS_SELECTOR:
				sequence_PropertyClassSelector(context, (PropertyClassSelector) semanticObject); 
				return; 
			case DSLPackage.PROPERTY_SELECTOR:
				sequence_PropertySelector(context, (PropertySelector) semanticObject); 
				return; 
			case DSLPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case DSLPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case DSLPackage.STATEMENT_MODALITY:
				sequence_StatementModality(context, (StatementModality) semanticObject); 
				return; 
			case DSLPackage.STATEMENT_TYPE:
				sequence_StatementType(context, (StatementType) semanticObject); 
				return; 
			case DSLPackage.SUBTRACT_OPERATION:
				sequence_SubtractOperation(context, (SubtractOperation) semanticObject); 
				return; 
			case DSLPackage.TARGET_MODEL_TYPE_DEF:
				sequence_TargetModelTypeDef(context, (TargetModelTypeDef) semanticObject); 
				return; 
			case DSLPackage.UNION_OPERATION:
				sequence_UnionOperation(context, (UnionOperation) semanticObject); 
				return; 
			case DSLPackage.VARIABLE_EQUALITY_OPERATION:
				sequence_VariableEqualityOperation(context, (VariableEqualityOperation) semanticObject); 
				return; 
			case DSLPackage.VARIABLE_INEQUALITY_OPERATION:
				sequence_VariableInequalityOperation(context, (VariableInequalityOperation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractElement returns AbstractElement
	 *
	 * Constraint:
	 *     {AbstractElement}
	 */
	protected void sequence_AbstractElement(ISerializationContext context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataSelector returns AttributeClassSelector
	 *     CharacteristicClassSelector returns AttributeClassSelector
	 *     AttributeClassSelector returns AttributeClassSelector
	 *
	 * Constraint:
	 *     ref=[CharacteristicClass|ID]
	 */
	protected void sequence_AttributeClassSelector(ISerializationContext context, AttributeClassSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeClassSelectorAccess().getRefCharacteristicClassIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataSelector returns AttributeSelector
	 *     CharacteristicSelector returns AttributeSelector
	 *     AttributeSelector returns AttributeSelector
	 *
	 * Constraint:
	 *     ref=CharacteristicTypeSelector
	 */
	protected void sequence_AttributeSelector(ISerializationContext context, AttributeSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_SELECTOR__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_SELECTOR__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeSelectorAccess().getRefCharacteristicTypeSelectorParserRuleCall_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns CharacteristicClass
	 *     CharacteristicClass returns CharacteristicClass
	 *
	 * Constraint:
	 *     (name=ID members+=CharacteristicTypeSelector members+=CharacteristicTypeSelector*)
	 */
	protected void sequence_CharacteristicClass(ISerializationContext context, CharacteristicClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns CharacteristicReference
	 *     CharacteristicReference returns CharacteristicReference
	 *
	 * Constraint:
	 *     value=[CharacteristicVariable|ID]
	 */
	protected void sequence_CharacteristicReference(ISerializationContext context, CharacteristicReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacteristicReferenceAccess().getValueCharacteristicVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(DSLPackage.Literals.CHARACTERISTIC_REFERENCE__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns CharacteristicSetReference
	 *     CharacteristicSetReference returns CharacteristicSetReference
	 *
	 * Constraint:
	 *     (value=[CharacteristicSet|ID] | ref=CharacteristsicSetOperation)
	 */
	protected void sequence_CharacteristicSetReference(ISerializationContext context, CharacteristicSetReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CharacteristicVariableType returns CharacteristicSet
	 *     CharacteristicSet returns CharacteristicSet
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CharacteristicSet(ISerializationContext context, CharacteristicSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_VARIABLE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_VARIABLE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacteristicSetAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CharacteristicTypeSelector returns CharacteristicTypeSelector
	 *
	 * Constraint:
	 *     (
	 *         ref=[CharacteristicType|ID] 
	 *         (
	 *             (negated?='!'? literals+=[EnumCharacteristicLiteral|ID]) | 
	 *             (literals+=[EnumCharacteristicLiteral|ID] literals+=[EnumCharacteristicLiteral|ID]*) | 
	 *             (isVariableSelector?='$' variable=CharacteristicVariableType)
	 *         )
	 *     )
	 */
	protected void sequence_CharacteristicTypeSelector(ISerializationContext context, CharacteristicTypeSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns CharacteristicType
	 *     CharacteristicType returns CharacteristicType
	 *
	 * Constraint:
	 *     (name=ID ref=[CharacteristicType|ID])
	 */
	protected void sequence_CharacteristicType(ISerializationContext context, CharacteristicType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_TYPE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_TYPE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacteristicTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCharacteristicTypeAccess().getRefCharacteristicTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(DSLPackage.Literals.CHARACTERISTIC_TYPE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CharacteristicVariableType returns CharacteristicVariable
	 *     CharacteristicVariable returns CharacteristicVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CharacteristicVariable(ISerializationContext context, CharacteristicVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_VARIABLE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_VARIABLE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacteristicVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     operation=BooleanOperation
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CONDITION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CONDITION__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getOperationBooleanOperationParserRuleCall_1_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Constraint
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=ID rule=Rule)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CONSTRAINT__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CONSTRAINT__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstraintAccess().getRuleRuleParserRuleCall_3_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns CreateSetOperation
	 *     CharacteristsicSetOperation returns CreateSetOperation
	 *     CreateSetOperation returns CreateSetOperation
	 *
	 * Constraint:
	 *     value=CharacteristicReference
	 */
	protected void sequence_CreateSetOperation(ISerializationContext context, CreateSetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CREATE_SET_OPERATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CREATE_SET_OPERATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateSetOperationAccess().getValueCharacteristicReferenceParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns ElementOfOperation
	 *     BooleanOperation returns ElementOfOperation
	 *     LogicalOrOperation returns ElementOfOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns ElementOfOperation
	 *     LogicalAndOperation returns ElementOfOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns ElementOfOperation
	 *     LogicalNegationOperation returns ElementOfOperation
	 *     EncapsulatedLogicalOperation returns ElementOfOperation
	 *     SimpleBooleanOperation returns ElementOfOperation
	 *     ElementOfOperation returns ElementOfOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicReference right=CharacteristicSetReference)
	 */
	protected void sequence_ElementOfOperation(ISerializationContext context, ElementOfOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ELEMENT_OF_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ELEMENT_OF_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ELEMENT_OF_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ELEMENT_OF_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementOfOperationAccess().getLeftCharacteristicReferenceParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getElementOfOperationAccess().getRightCharacteristicSetReferenceParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns EmptySetOperation
	 *     BooleanOperation returns EmptySetOperation
	 *     LogicalOrOperation returns EmptySetOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns EmptySetOperation
	 *     LogicalAndOperation returns EmptySetOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns EmptySetOperation
	 *     LogicalNegationOperation returns EmptySetOperation
	 *     EncapsulatedLogicalOperation returns EmptySetOperation
	 *     SimpleBooleanOperation returns EmptySetOperation
	 *     EmptySetOperation returns EmptySetOperation
	 *
	 * Constraint:
	 *     value=CharacteristicSetReference
	 */
	protected void sequence_EmptySetOperation(ISerializationContext context, EmptySetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.BOOLEAN_OPERATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.BOOLEAN_OPERATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptySetOperationAccess().getValueCharacteristicSetReferenceParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Include
	 *     Include returns Include
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.INCLUDE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.INCLUDE__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns IntersectionOperation
	 *     CharacteristsicSetOperation returns IntersectionOperation
	 *     IntersectionOperation returns IntersectionOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicSetReference right=CharacteristicSetReference)
	 */
	protected void sequence_IntersectionOperation(ISerializationContext context, IntersectionOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.INTERSECTION_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.INTERSECTION_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.INTERSECTION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.INTERSECTION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntersectionOperationAccess().getLeftCharacteristicSetReferenceParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIntersectionOperationAccess().getRightCharacteristicSetReferenceParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns LogicalAndOperation
	 *     BooleanOperation returns LogicalAndOperation
	 *     LogicalOrOperation returns LogicalAndOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns LogicalAndOperation
	 *     LogicalAndOperation returns LogicalAndOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns LogicalAndOperation
	 *     LogicalNegationOperation returns LogicalAndOperation
	 *     EncapsulatedLogicalOperation returns LogicalAndOperation
	 *
	 * Constraint:
	 *     (left=LogicalAndOperation_LogicalAndOperation_1_0 right=LogicalNegationOperation)
	 */
	protected void sequence_LogicalAndOperation(ISerializationContext context, LogicalAndOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LOGICAL_AND_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LOGICAL_AND_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LOGICAL_AND_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LOGICAL_AND_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalAndOperationAccess().getLogicalAndOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalAndOperationAccess().getRightLogicalNegationOperationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns BooleanOperation
	 *     BooleanOperation returns BooleanOperation
	 *     LogicalOrOperation returns BooleanOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns BooleanOperation
	 *     LogicalAndOperation returns BooleanOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns BooleanOperation
	 *     LogicalNegationOperation returns BooleanOperation
	 *     EncapsulatedLogicalOperation returns BooleanOperation
	 *
	 * Constraint:
	 *     value=EncapsulatedLogicalOperation
	 */
	protected void sequence_LogicalNegationOperation(ISerializationContext context, BooleanOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.BOOLEAN_OPERATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.BOOLEAN_OPERATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalNegationOperationAccess().getValueEncapsulatedLogicalOperationParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns LogicalOrOperation
	 *     BooleanOperation returns LogicalOrOperation
	 *     LogicalOrOperation returns LogicalOrOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns LogicalOrOperation
	 *     LogicalAndOperation returns LogicalOrOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns LogicalOrOperation
	 *     LogicalNegationOperation returns LogicalOrOperation
	 *     EncapsulatedLogicalOperation returns LogicalOrOperation
	 *
	 * Constraint:
	 *     (left=LogicalOrOperation_LogicalOrOperation_1_0 right=LogicalAndOperation)
	 */
	protected void sequence_LogicalOrOperation(ISerializationContext context, LogicalOrOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LOGICAL_OR_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LOGICAL_OR_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LOGICAL_OR_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LOGICAL_OR_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalOrOperationAccess().getLogicalOrOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalOrOperationAccess().getRightLogicalAndOperationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((targetModelType=TargetModelTypeDef elements+=AbstractElement+) | elements+=AbstractElement+)?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DestinationSelector returns NodeIdentitiySelector
	 *     NodeIdentitiySelector returns NodeIdentitiySelector
	 *
	 * Constraint:
	 *     (name=STRING | (assembly=[AssemblyContext|ID] component=[BasicComponent|ID] seff=[ServiceEffectSpecification|ID]))
	 */
	protected void sequence_NodeIdentitiySelector(ISerializationContext context, NodeIdentitiySelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CharacteristicClassSelector returns PropertyClassSelector
	 *     DestinationSelector returns PropertyClassSelector
	 *     PropertyClassSelector returns PropertyClassSelector
	 *
	 * Constraint:
	 *     ref=[CharacteristicClass|ID]
	 */
	protected void sequence_PropertyClassSelector(ISerializationContext context, PropertyClassSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyClassSelectorAccess().getRefCharacteristicClassIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DSLPackage.Literals.CHARACTERISTIC_CLASS_SELECTOR__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CharacteristicSelector returns PropertySelector
	 *     DestinationSelector returns PropertySelector
	 *     PropertySelector returns PropertySelector
	 *
	 * Constraint:
	 *     ref=CharacteristicTypeSelector
	 */
	protected void sequence_PropertySelector(ISerializationContext context, PropertySelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.CHARACTERISTIC_SELECTOR__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.CHARACTERISTIC_SELECTOR__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertySelectorAccess().getRefCharacteristicTypeSelectorParserRuleCall_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (
	 *         dataSelectors+=DataSelector 
	 *         dataSelectors+=DataSelector* 
	 *         statement=Statement 
	 *         destinationSelectors+=DestinationSelector 
	 *         destinationSelectors+=DestinationSelector* 
	 *         condition=Condition?
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementModality returns StatementModality
	 *
	 * Constraint:
	 *     name='NEVER'
	 */
	protected void sequence_StatementModality(ISerializationContext context, StatementModality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.STATEMENT_MODALITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.STATEMENT_MODALITY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementModalityAccess().getNameNEVERKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementType returns StatementType
	 *
	 * Constraint:
	 *     name='FLOWS'
	 */
	protected void sequence_StatementType(ISerializationContext context, StatementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.STATEMENT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.STATEMENT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementTypeAccess().getNameFLOWSKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (modality=StatementModality type=StatementType)
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.STATEMENT__MODALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.STATEMENT__MODALITY));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.STATEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.STATEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getModalityStatementModalityParserRuleCall_0_0(), semanticObject.getModality());
		feeder.accept(grammarAccess.getStatementAccess().getTypeStatementTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns SubtractOperation
	 *     CharacteristsicSetOperation returns SubtractOperation
	 *     SubtractOperation returns SubtractOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicSetReference right=CharacteristicSetReference)
	 */
	protected void sequence_SubtractOperation(ISerializationContext context, SubtractOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.SUBTRACT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.SUBTRACT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.SUBTRACT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.SUBTRACT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtractOperationAccess().getLeftCharacteristicSetReferenceParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubtractOperationAccess().getRightCharacteristicSetReferenceParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TargetModelTypeDef returns TargetModelTypeDef
	 *
	 * Constraint:
	 *     (type=TargetModelType (typeContainer=[CharacteristicTypeContainer|ID] (allocationModel=[Allocation|ID] usageModel=[UsageModel|ID])?)?)
	 */
	protected void sequence_TargetModelTypeDef(ISerializationContext context, TargetModelTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns UnionOperation
	 *     CharacteristsicSetOperation returns UnionOperation
	 *     UnionOperation returns UnionOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicSetReference right=CharacteristicSetReference)
	 */
	protected void sequence_UnionOperation(ISerializationContext context, UnionOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.UNION_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.UNION_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.UNION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.UNION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnionOperationAccess().getLeftCharacteristicSetReferenceParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getUnionOperationAccess().getRightCharacteristicSetReferenceParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns VariableEqualityOperation
	 *     BooleanOperation returns VariableEqualityOperation
	 *     LogicalOrOperation returns VariableEqualityOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns VariableEqualityOperation
	 *     LogicalAndOperation returns VariableEqualityOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns VariableEqualityOperation
	 *     LogicalNegationOperation returns VariableEqualityOperation
	 *     EncapsulatedLogicalOperation returns VariableEqualityOperation
	 *     SimpleBooleanOperation returns VariableEqualityOperation
	 *     VariableEqualityOperation returns VariableEqualityOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicReference right=CharacteristicReference)
	 */
	protected void sequence_VariableEqualityOperation(ISerializationContext context, VariableEqualityOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.VARIABLE_EQUALITY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.VARIABLE_EQUALITY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.VARIABLE_EQUALITY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.VARIABLE_EQUALITY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableEqualityOperationAccess().getLeftCharacteristicReferenceParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVariableEqualityOperationAccess().getRightCharacteristicReferenceParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns VariableInequalityOperation
	 *     BooleanOperation returns VariableInequalityOperation
	 *     LogicalOrOperation returns VariableInequalityOperation
	 *     LogicalOrOperation.LogicalOrOperation_1_0 returns VariableInequalityOperation
	 *     LogicalAndOperation returns VariableInequalityOperation
	 *     LogicalAndOperation.LogicalAndOperation_1_0 returns VariableInequalityOperation
	 *     LogicalNegationOperation returns VariableInequalityOperation
	 *     EncapsulatedLogicalOperation returns VariableInequalityOperation
	 *     SimpleBooleanOperation returns VariableInequalityOperation
	 *     VariableInequalityOperation returns VariableInequalityOperation
	 *
	 * Constraint:
	 *     (left=CharacteristicReference right=CharacteristicReference)
	 */
	protected void sequence_VariableInequalityOperation(ISerializationContext context, VariableInequalityOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.VARIABLE_INEQUALITY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.VARIABLE_INEQUALITY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.VARIABLE_INEQUALITY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.VARIABLE_INEQUALITY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableInequalityOperationAccess().getLeftCharacteristicReferenceParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVariableInequalityOperationAccess().getRightCharacteristicReferenceParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
