/*
 * generated by Xtext 2.20.0
 */
package de.sebinside.dcp.dsl.generator

import de.sebinside.dcp.dsl.dSL.CharacteristicClass
import de.sebinside.dcp.dsl.dSL.Constraint
import de.sebinside.dcp.dsl.dSL.TargetModelTypeDef
import de.sebinside.dcp.dsl.generator.crossplatform.Converter
//import de.sebinside.dcp.dsl.generator.crossplatform.PalladioConverter
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.palladiosimulator.supporting.prolog.model.prolog.Clause
import org.palladiosimulator.supporting.prolog.model.prolog.PrologFactory

import static de.sebinside.dcp.dsl.generator.util.DSLGeneratorUtils.*
import static de.sebinside.dcp.dsl.generator.util.PrologUtils.*
import org.palladiosimulator.dataflow.confidentiality.transformation.prolog.DFD2PrologTransformationTrace
import de.sebinside.dcp.dsl.dSL.Model
import de.sebinside.dcp.dsl.generator.queryrule.InputPinQueryRule
import de.sebinside.dcp.dsl.dSL.Rule
import de.sebinside.dcp.dsl.generator.crossplatform.DFDConverter

class DSLGenerator extends AbstractGenerator {

	static final String DEFAULT_OUTPUT_FILE_NAME = "output.pl"
	static final String DSL_EXTENSION = ".DCPDSL"
	static final String PROLOG_EXTENSION = ".pl"

	// Setting the default value
	protected Converter converter = null
	protected String targetModelType = "DFD"
	
	DFD2PrologTransformationTrace extendedDFDConverterTrace = null

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = generateFromResource(resource)

		val outputFileName = if (resource.URI.lastSegment !== null) {
				resource.URI.lastSegment.replace(DSL_EXTENSION, PROLOG_EXTENSION)
			} else {
				DEFAULT_OUTPUT_FILE_NAME
			}
		saveFile(fsa, resource, program, outputFileName)
	}
	
	def generateFromModel(Model model) {
		val program = PrologFactory.eINSTANCE.createProgram
		model.targetModelType.compile
		
		for (charClass : model.elements.filter(CharacteristicClass)) {
			program.clauses.addAll(charClass.compile)
		}
		
		for (constraint : model.elements.filter(Constraint)) {
			program.clauses.addAll(constraint.compile)
		}
		
		program
	}
	
	def generateFromResource(Resource resource) {
		val program = PrologFactory.eINSTANCE.createProgram

		for (element : resource.allContents.toIterable.filter(TargetModelTypeDef)) {
			element.compile
		}

		for (element : resource.allContents.toIterable.filter(CharacteristicClass)) {
			program.clauses.addAll(element.compile)
		}

		for (element : resource.allContents.toIterable.filter(Constraint)) {
			program.clauses.addAll(element.compile)
		}
		
		program
	}
	
	def setDFD2PrologTrace(DFD2PrologTransformationTrace trace) {
		this.extendedDFDConverterTrace = trace;
	}

	def compile(TargetModelTypeDef typeDefs) {
		// There is only one or none target model type definition
		this.targetModelType = typeDefs.type
		if (targetModelType.equals("DFD")) {
			if(extendedDFDConverterTrace === null) {
					throw new Exception("No valid trace for DFD!")
			}
				this.converter = new DFDConverter(extendedDFDConverterTrace)
		}
	}

	def List<Clause> compile(CharacteristicClass charateristicClass) {
		val clauses = new ArrayList<Clause>

		// Create rule referencing all facts
		val rule = Rule('''«GlobalConstants.Prefixes.CHARACTERISTICS_CLASS»«charateristicClass.name»''')
		rule.body = null

		// A rules arguments are all contained member type names
		rule.head.arguments.addAll(charateristicClass.members.map[member|member.ref.name].toSet.map [ type |
			CompoundTerm('''«GlobalConstants.Prefixes.CLASS_VARIABLE»«charateristicClass.name»_«type»''')
		].toList)

		// Create single facts for every member
		charateristicClass.members.forEach [ member, index |
			member.literals.forEach [ literal |

				// Create and add fact
				val factName = '''«GlobalConstants.Prefixes.CHARACTERISTICS_CLASS»«charateristicClass.name»_«member.ref.name»_«index»«if(member.negated) "_NEG"»'''
				val fact = SimpleFact(factName, converter.convert(literal))
				clauses.add(fact)

				// Create fact reference for the rule
				val factReference = CompoundTerm(fact.head.value,
					CompoundTerm('''«GlobalConstants.Prefixes.CLASS_VARIABLE»«charateristicClass.name»_«member.ref.name»'''))

				// Handle negated facts
				val factExpression = if (member.negated) {
						NotProvable(factReference)
					} else {
						factReference
					}

				// A rule body consists of one or multiple combined facts
				if (rule.body === null) {
					rule.body = factExpression
				} else {
					rule.body = LogicalAnd(rule.body, factExpression)
				}
			]
		]

		// Add member queries to the class directly
		// FIXME: Might contain duplicates
		val memberQueries = charateristicClass.members.map [ member |
			createMemberQuery(converter.convertMember(member.ref),
				CompoundTerm('''«GlobalConstants.Prefixes.CLASS_VARIABLE»«charateristicClass.name»_«member.ref.name»'''))
		]
		val memberQueriesTerm = expressionsToLogicalAnd(memberQueries);

		if (memberQueries !== null) {
			// Note: The ordering is crucial!
			rule.body = LogicalAnd(memberQueriesTerm, rule.body)
		}

		clauses.add(rule)
		clauses
	}

	def List<Clause> compile(Constraint constraint) {
		val clauses = new ArrayList<Clause>
		val constraintName = '''«GlobalConstants.Prefixes.CONSTRAINT»«constraint.name»'''
		val constraintNameTerm = createConstraintNameUnification(constraint.name)

		// Every constraint is mapped to a rule
		val constraintRule = Rule(constraintName)

		// FIXME: The first iteration does only support one rule per constraint
		val mainRule = constraint.rule

		// FIXME: The first iteration does only support NEVER FLOW statements
		if (!mainRule.statement.modality.name.equals("NEVER") || !mainRule.statement.type.name.equals("FLOWS")) {
			throw new Exception("Unable to generate. Unsupported modality or statement type.")
		} else {

			var rules = new ArrayList<org.palladiosimulator.supporting.prolog.model.prolog.Rule>()
			// FIXME: The combination of this rules is not everytime clear in previously modeled use cases
			rules.add(generateRule(mainRule, constraintName, this.converter))
			// Only the operation model works with all kinds of rules, Palladio only requires preCallStates
//			if (this.targetModelType == TargetModelType.OPERATION_MODEL) {
//				rules.add(new OutputPinQueryRule(mainRule, constraintName, converter).generate())
//			}

			// Combine rules
			constraintRule.body = expressionsToLogicalOr(rules.map[rule|ruleToRuleCall(rule)])

			// Add constraint name unification
			constraintRule.body = LogicalAnd(constraintNameTerm, constraintRule.body)
			constraintRule.head.arguments.add(CompoundTerm('''«GlobalConstants.Parameters.CONSTRAINT_NAME»'''))

			// Combine (unique) arguments of all rules
			val allArguments = combineRuleArguments(rules)
			constraintRule.head.arguments.addAll(allArguments)

			clauses.add(constraintRule)
			clauses.addAll(rules)
		}
		clauses
	}
	
	def generateRule(Rule mainRule, String constraintName, Converter converter) {
		var inputRule = new InputPinQueryRule(mainRule, constraintName, converter)
		inputRule.generate()
	}

}
